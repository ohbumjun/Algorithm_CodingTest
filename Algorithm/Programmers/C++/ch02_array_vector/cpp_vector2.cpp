/*

operator[] : 특정 위치 원소의 '참조'를 반환
front()    : 첫번째 원소의 '참조'를 반환
back()     : 마지막 원소의 '참조'를 반환

push_back()    : 마지막에 원소 추가
emplace_back() : 객체의 복제나 이동이 없어서 효율적
pop_back()     : 마지막 원소를 삭제(마지막 원소를 반환하지 않음)

1) push_back :
- 현재 원소를 넣으려는 vector의 capacity가 작다면,
- capacity를 2배로 키운, 새로운 배열 생성
- memcpy를 통해 원소 복사 
- 기존 포인터가 가리키는 배열의 주소를 새로운 배열로
- 새로운 공간에 원소 추가 
- 기존 메모리 공간은 해제

2) insert, erase
- vec1.insert(vec1.begin(), 0); --> 제일 처음 원소 위치에 0 삽입 
- vec1.erase(vec1.begin() + 1, vec.begin() + 3); --> 1번째 부터 3번째 이전(2번째 까지)를 지운다.
여기서, 실제 지우는 과정을 거치는 것이 아니라, 뒤쪽에 있는 녀석들을 앞으로 이동시키는 과정을 거친다. 
그리고 size 를 지우는 만큼 감소 시킨다.
즉, erase의 경우, capacity는 변경하지 않고, size 값만 변경시켜준다.
- vec1.end() : 제일 마지막 원소 다음 위치
 
*/

/*
프로그램이 실행되기 위해서는
os가 프로그램의 정보를, 메모리에 로드해야 한다.

프로그램이 실행되는 동안, 
cpu가 코드를 처리하기 위해서는, 메모리가 명령어와, 데이터들을 저장해야 한다.

코드 영역 : 실행할 프로그램의 코드
데이터 영역 : 전역 변수, 정적 변수
힙 영역 : 사용자의 동적 할당 ( 런타임에 크기가 결정된다 )
스택 영역 : 지역 변수, 매개 변수 ( 컴파일 타임에 크기가 결정된다. )
*/