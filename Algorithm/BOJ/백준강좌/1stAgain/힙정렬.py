# 힙정렬
'''
배열로 표현하고자 할때
1) 현재 idx * 2     = 왼쪽 자식 idx
2) 현재 idx * 2 + 1 = 오른쪽 자식 idx

반대로,
자신 idx // 2 = 자신의 부모 idx

1) 먼저 배열을 힙정렬 할때
해당 배열을 , max heap 형태로 만들어주어야 한다.

부모가 두 자식보다 값이 커야 max heap이다.
즉, 맨 위 루트 노드가 제일 큰 값이 될 것이다.

HOW ?
가장 밑단에서부터 maxheap을 만들면서 올라간다.
그러면, 먼저
자식이 있는 부모노드 중 맨 마지막을 찾아야 한다.

어떻게 찾는데 ?

* size = 배열 자료의 개수
자료의 맨 마지막은, 우선 맨 마지막 노드일 것이다 ( 맨 아래 )

즉, 맨 마지막 자료의 부모 노드( 맨 마지막 idx // 2 ) 가.
자식이 있는 부모노드 중 맨 마지막일 것이고
거기서부터 maxheap을 만들어가면서
전체 maxheap을 구성해가는 원리이다.

35 55 19 55 60 34 10 30 22 15 32
가 있다면

맨 마지막 32 가 마지막 노드이고
34가 바로, 자식이 있는 맨 마지막 부모노드.일 것이다

maxheap(p) : 
함수를 만들고
p에는 부모 노드를 보내는 것이다

size // 2  ~ 0번째 idx 까지 돌면서
maxheap을 만들어나가는 것이다

p라는 부모노드를 넣었을 때
해당 세트가 maxheap이면 그냥 올라가고

maxheap이 아니라면
maxheap을 만들고 나서, 그 다음 올라간다.
여기서는 부모가 왼쪽, 오른쪽 자식보다 큰 지는 검사한다
즉, 부모로서의 자격이 있는지를 검사한다.

그렇다면, 현재 부모가 왼쪽, 오른쪽 자식보다 작다면
현재 부모 노드 값을 아래로 내보내면서
자신의 위치를 찾아가도록 해야 한다

tmp = arr[p] // 부모 노드 저장
만약, 부모가 왼쪽 자식으로 내려간다면
또 거기에서의 왼쪽, 오른쪽 자식을 또 비교해간다
즉, 계속 반복해가는 것이다

while p <= size // 2 :

왜 p <= size // 2 ?

어차피 현재 검사하는 부모 노드는
맨 아래로 내려갈 수 있는데
맨 아래로 내려갈 경우에는, 자식노드 자체가 없다
즉, p는 여기서 부모노드가 될 수 있는 idx들만이 들어가므로
부모노드 idx의 최대값인 size // 2까지만 비교하는 것이다.

while p <= size // 2 :
    c = p * 2 // c : 부모의 왼쪽 자식 idx
    // arr[c] < arr[c+1] : 오른쪽 자식이 왼쪽 자식보다 크다면
    // c < size : c + 1이 out of idx 안되게 하기 위해 
    // 예를 들어, 자료 개수가 10개라면 1 ~ 10 idx 에 자료를 배치하며
    // c + 1이 arr 상에 존재하려면 c 가 10이 되어서는 안되고, 9까지만 가능하다
    if c < size and arr[c] < arr[c+1] :
        c += 1 // c가 오른쪽 자식을 가리키게 한다
    
    // 여기까지 오면, c가 왼쪽 혹은 오른쪽 자식 중에서 큰 값을 가리키고 있게 된다.
    if tmp > arr[c] :
        // 부모가 자식보다 크다 ? 그러면 maxheap 통과
        // while문 끝내고, 위 부모 heap으로
        break
    else:
        // 부모 값에 자식 값을 넣어준다
        arr[p] = arr[c]
        // 부모 idx 위치를 c로 바꿔주고, 다시 while문 올라가서 maxheap 반복
        p = c 
    

    이렇게 모든 것이 끝나면
    arr[p] = tmp

    이렇게 넣어주면 된다.

    즉, 이러한 maxHeap() 함수를
    부모 노드들인 1 ~ size // 2 idx 까지 적용하고 나면

    우리는 힙정렬을 
    완료한 것이 아니라 !!!!

    maxheap 을 만든 것이다.

    즉, 
    35 55 19 55 60 34 10 30 22 15 32
    가
    60 35 55 22 34 10 30 19 15 32
    로 정렬된 것이다.

    이제는 정렬을 할 차례

    어떻게 정렬을 하느냐 !!
    maxheap을 만들어 놓으면
    root에는 가장 큰 값이 들어있다
    1 idx에는 가장 큰 값이 들어있다.

    가장 큰 값을 맨 뒤로
    size  idx로 옮기는 것이다
    32 35 55 22 34 10 30 19 15 60
    ( 맨 앞, 맨 뒤 바뀜)

    이후 size를 1 감소시킨다

    size는 이제 9
    size를 1 감소시킨다는 것은
    60 이라는 애를 이제

    heap상에서 아예 제거한다는 것이다
    60은 이제 정렬된 것이고
    자기 자리를 찾은 것이므로
    그 앞의 요소들만 이제 heap 요소로 고려하겠다는 것.

    그 다음 maxheap을 또 호출한다.
    왜 ?
    한번 maxheap에서   
    32 35 55 22 34 10 30 19 15 
    이렇게 바뀌면, 
    루트 노드에 새로운 값이 들어온 것이고
    maxheap 형태를 만족시키지 않으므로
    다시 heap정렬을 실시해야 한다

    여기서는 루트 노드에 들어온
    새로운 값에 대해서만 maxheap만들기를
    진행하면 되기때문에
    maxheap(1)을 호출하며
    size가 1이 될때까지 계속 반복한다.

    즉, 
    루트 노드 ~ size 바꿔주고
    maxheap(1)
    를 계속 반복하는 것이다.


'''

def maxHeap(p):
    tmp = arr[p]
    while p <= size // 2 :
        c = p * 2
        if c < size  and arr[c] < arr[c+1] :
            c += 1
        if tmp > arr[c] : break
        arr[p] = arr[c]
        p = c

    arr[p] = tmp

def Hsort():
    global size
    # 1 번째 idx까지 도는 이유는 1번째 idx가 루트노드를 가리키는 idx이고
    # 0번째 idx는 사실상 안사용하기 때문이다
    for i in range(size // 2, 0, -1 ):
        maxHeap(i)

    while size > 1 :
        arr[size] , arr[1] = arr[1], arr[size]
        size -= 1
        maxHeap(1)

if __name__ == "__main__" :
    # 0번째 idx는 빈공간으로 놔두고
    # 1번째 idx부터 활용할 것이다.
    arr  = [0, 35, 19, 55, 60, 34, 10, 30, 22, 15, 32]
    size = len(arr) - 1
    print("Before sort", end = '')
    print(arr)
    Hsort()
    print("After sort", end = '')
    print(arr) 

