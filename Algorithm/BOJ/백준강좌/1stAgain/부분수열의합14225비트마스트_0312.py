'''
비트 마스크란 무엇인가?

비트 마스크는, 집합을 정수로 표현한 것이다.

여기서의 집합은 0 부터 n -1 까지의 정수로 이루어진 것

정수로 표현하는 방법은, 비트로 표현하는 것
비트 : 0 1 0 1 0 0 1
정수 : 1 2 3 4 4 5 6

결국 비트가 1인 정수들의 집합 = [ 2, 4, 6 ]

이것을 정수로 표현하면
2 ^ 2 + 2 ^ 4 + 2 ^ 6 이 되는 것이다. 

-------------------------------------------------
조금 더 자세히 설명해보자. 
[ 1, 1, 0] 이라는 배열이 있을 때,
idx 1에 값이 있는지 없는지 조사하기 위해서는, 일반적으로 for문을 돈다

그런데 만일 배열을 이진수처럼 표현한다면 ?
110 ( 2 ) = 6

0번째 idx에 값이 1인지 아닌지를 보려면
6 & ( 1 << 2 )를 하면된다.

??  ( 1 << 2) 는 뭔데 ?
1을 이진법 상에서 2만큼 왼쪽으로 옮긴 것

즉, 2 ^ 2 = 4 라는 것이다.

110 이라는 2진법에서 맨왼쪽 4, 
즉, 1 << 2 는 1로서 존재한다.

이때 
print( 6 & ( 1 << 2) ) 는 4라는 값을 출력한다.

하지만, 
1 << 0 : 1

그런데 110 에서 1은 존재하지 않는다( 맨 오른쪽이 1 이 아니라, 0)

그래서 
print( 6 & ( 1 << 0 ))은 '없다'라는 의미로 '0'을 출력한다.

이를 부분배열에서의 '포함여부'로 구분할 수 있다

예를 들어,
[사과 , 포도, 배열] 의 부분 수열 중에서 ,
1 1 1 : 모두 포함된 것
1 1 0 : 사과, 포도 only

이러한 식으로 접근할 수 있다는 것이다.

'''

n = int(input())
a = list(map(int, input().split()))
# c는 일종의 체크리스트이다. 해당 숫자가 만들어진적이 있는지 없는지
# n은 최대 20, 각 숫자의 최대값은 100000, 그래서 최대 20 * 100000 의 숫자가 만들어 질 수 있는 것이다.
# 아래에서 20 대신에 n을 써도 된다( 사실 써야 한다... 공간 복잡도를 줄이기 위해서 )
c = [False]*(20 * 100000)

# 이게 무슨 말이냐면, 조합의 경우수를 전제 조사하는 것이다
# 0000, 0001, 0011 .... 1111 .... ?
# 1 << n 보다 하나작다는 것이므로 --> 1이 모두 n개 있는 것 ( n-1개가 아니라 )
# 0000 .... 이 모든 비트마스크는, a의 부분수열을 의미한다
for i in range(1 << n):
    s = 0
    for j in range(n):
        # ex) 현재 i 조합은 0001 인데, 1 << j, 즉, 맨오른쪽 1 값이 존재하느냐
        # 즉, 배열 기준, 맨 오른쪽 값이 현재 부분수열에 포함되어 있느냐
        if (i & (1 << j)):
            s += a[j]
    c[s] = True
i = 1
##
while True:
    if c[i] == False:
        break
    i += 1
print(i)
