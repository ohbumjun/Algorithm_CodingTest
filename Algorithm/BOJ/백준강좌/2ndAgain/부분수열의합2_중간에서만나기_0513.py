'''
중간에서 만나기

A도시가 있고
B도시가 있다고 해보자 
A ~ B

A에서 B로 가는 시간은 60분 
B에서 A로 가는 시간도 60분
이라고 해보자 

즉, A에 1사람이 있고, B에 1사람이 있다.
A가 B에 있는 사람을 만나러 가는데 걸리는 시간 60분
B -> A 도 60분.


이때, 두 사람이 만나는 데 걸리는 시간은 60분이며,
각 사람의 이동 시간 합도 60분이 된다 
( ex. A가 B를 만나러 갈때는, A가 60분 걸리고, B는 움직이지 않으니까 0분 )

그런데, 만약 A와 B 사이에 C라는 중간점에서 두 사람이 만난다고 해보자.
이 경우에는
두 사람이 만나는데 걸리는 시간은 30분으로 줄어들고,
각 사람의 이동 시간합은 60분이 될 것이다. 

< 중간에서 만나기 적용 방법 >
- 문제를 절반으로 나눠서
- 양쪽 절반에서 모든 경우를 다 해보는 방법
- 탐색의 크기가 많이 줄어든다
- 문제의 크기가 N인 경우에 2 ^ N 에서
- M = N / 2 라고 하면, 2 ^ M + 2 ^ M 으로 줄어들게 된다 


< 해당 문제 적용 > 
해당 문제의 부분수열의 가능한 모든 개수는 ( 원소의 최대 개수는 40개 )
2 ^ 40 - 1개 이다 ( 크기가 양수 ... 즉, 아예 없는 경우는 해당하지 않는 것 )

그런데 이는 1조.....
즉, 브루트 포스 방식으로 적용할 수 없다.

그렇다면, 이것을 각각 반으로 나누면
20개, 20개 

그리고 각각의 부분수열의 가능한 모든 개수는
2 ^ 20, 2 ^ 20

각각에 대해서 가능한 부분수열을 구하는 것은 1 000 000

왼쪽 부분수열 하나하나 마다, 오른쪽 부분수열 하나하나를 적용해가면서
문제를 푸는 원리인 것이다. 

예를 살펴보자. 부분수열의 합이 4인 경우의 수를 구해야 한다 

A = [ 1, 2, 1, 3, 2, 1 ]
A를 left, right으로 나눠서 [1, 2, 1] , [3, 2, 1] 이라고 해보자 

left 에서 만들어지는 부분수열 : [], [1], [2], [1], [1,2], [1,1], [2,1], [1,2,1]
right "" "" : [], [3], [2], [1], [3,2], [3,1], [2,1], [3,2,1]

각 부분수열의 합들을 구하고, 정렬을 시키면
left  : [0, 1, 1, 2, 2, 3, 4, 5]
right : [0, 1, 2, 3, 3, 4, 5, 6]

left  맨 처음   idx에서 시작 > 오른쪽 이동 ( lP)
right 맨 마지막 idx에서 시작 > 왼쪽 이동 ( rP )

자. 이제부터 할일은
lP + rP 가 4일 때는 찾는다
처음에는 lP가 가리키는 값이 0
rP가 가리키는 값이 6

4보다 크기 때문에
rP를 왼쪽으로 쭉 이동 시킨다.

lP : 0, rP : 4 인 경우를 발견할 수 있다

이때 중요한 점은
left에 0이 몇개인지 , right에 4가 몇개인지 구한 이후,
2개의 개수를 곱해준다.

?? 왜 ??
우선 보자.
lefㅅ에서 0은 1개, right에서도 4는 1개

따라서 이 경우는 1 * 1 을 최종 answer 에 더해준다 

-------------------------------------------------

자. 이제 다시 이동할 것이다
lP는 오른쪽 한칸, rP는 왼쪽 한칸 이동시킨다.

lP가 가리키는 값 1, rP가 가리키는 값 3 을 발견했다.
그런데 left에는 1이 2개
rP에도 3이 2개이다.

어차피 합이 4인 경우의 수를 구하는 것이므로
각각의 조합을 다 더해주면 되는 것이다
따러서 최종 answer에다가 2*2 를 곱해주고

lP는 1보다 큰 수, rP는 3보다 작은 수를 만날 때까지
각각 오른쪽, 왼쪽으로 쭉 이동시켜주면 되는 것이다. 


이러한 과정을 반복하여, 최종 답을 구하면 된다 

-----------------------------------------------
그렇다면 시간복잡도는 어떻게 계산될까 ?

1) N을 2//N으로 나눈다( 편의상 M 개 라고 하자) 
- 그 안에서, 나올 수 있는 모든 부분수열의 경우의 수를 구한다 2 ^ M
2) 그 대상들의 합을 정렬한다
- 2^M log (2^M)
3) 2개 left, right 합들을 비교해간다 ( 각각 총 2^M개를 탐색하는 것 )
- 2^M

즉, 2^M + 2^M log( 2 ^ M ) + 2 ^ M 라는 시간복잡도를 결과적으로 얻을 수 있다 

이는 2 ^ M log( 2 ^ M )이라고 할 수 있으며
M * 2 ^ M log 2 라고 할 수 있고, 상수를 제거하면

M * 2 ^ M . 이라는 최종의 시간복잡도를 얻게 된다. 

'''

import sys
import heapq
sys.stdin = open("input.txt", "rt")
sys.setrecursionlimit(100000)

n, s = map(int, input().split())
arr = list(map(int, input().split()))
res = 0

# right
M = n // 2
# left
N = n - M

first = [0] * (1 << N)
second = [0] * (1 << M)

# 부분 수열 경우의 수 할당해주기
for i in range(1 << N):
    # 1 << N ?? ex) 0000 ~~ 1111
    for k in range(N):
        # i & i<<k 라는 것은 k번째 해당하는 숫자가 포함되는 경우 ( 어려우면 비트마스크 공부 ㄱ )
        if (i & (1 << k)) > 0:
            first[i] += arr[k]


for j in range(1 << M):
    for k in range(M):
        if (j & (1 << k)) > 0:
            second[j] += arr[k+N]

# first, second 배열 각각의 원소에는, 각각 부분수열 합이 저장되어 있다
first.sort()
second.sort()

# second는 뒤집는다( 위의 설명과 달리, right 경우도, 맨왼쪽에서 시작 )
second.reverse()


fP = 0
sP = 0
fLen = len(first)
sLen = len(second)

while fP < fLen and sP < sLen:
    if first[fP] + second[sP] == s:
        fNum = 1
        sNum = 1
        fP += 1
        sP += 1
        while fP < fLen and first[fP] == first[fP - 1]:
            fNum += 1
            fP += 1
        while sP < sLen and second[sP] == second[sP - 1]:
            sNum += 1
            sP += 1

        res += (fNum * sNum)

    # 작으면, left 를 오른쪽으로
    elif first[fP] + second[sP] < s:
        fP += 1
    # 크면, right을 오른쪽으로
    else:
        sP += 1

if s == 0:
    res -= 1

print(res)
