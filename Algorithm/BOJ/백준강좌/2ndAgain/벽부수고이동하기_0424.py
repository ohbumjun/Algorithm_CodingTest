# https://www.acmicpc.net/problem/2206

import sys
from collections import deque
sys.stdin = open("input.txt", "rt")
sys.setrecursionlimit(1001*1001)

'''
가중치가 모두 1이고
최단 거리.를 구하는 문제이기 때문에

bfs ----------------------------------------------------------------------------------------

단, 여기서 까다로운 문제가 있다면

벽을 부수는 행위

벽은 한번 부술 수 있다고 했다

1) 원래 bfs 문제 : 빈칸 > 빈칸

2) 해당 문제 4가지 경우
빈칸 > 빈칸 ( 항상 가능  )
벽   > 벽   ( 항상 불가능 : 벽에서 이동한다는 것은 , 이미 한번 벽을 깼다는 것이기 때문이다 )
빈칸 > 벽   ( 이미 한번 벽을 부순 상황이면, 불가능 / 처음 부수는 것이라면, 이동 가능 )
벽   > 빈칸 ( 항상 가능  )

bfs 에서는 ---------------------------------------------------------------------------------

특정 점까지의 거리는 dist 라는 배열에 저장한다.

이 경우는 추가적인 경우를 생각해야 한다

ex) ( x, y )위치에 있는 점까지의 거리가

1) 벽을 한번 부수고 이동했을 때
2) 벽을 한번도 부수지 않고 이동했을 때

2가지 경우가 생긴다는 것이다

따라서,
dist[x][y][z]

x,y : 위치
z : 벽을 부순 횟수 ( 0 or 1 )

로 설정해주고 bfs를 진행해야 한다

bfs ----------------------------------------------------------------------------------------

bfs는 차근차근 퍼져나가는 구조이다
즉, 이미 방문한 정점은 다시 방문하지 않는다

이에 따라 이미 방문했는지, 안했는지를 계속 기록해줘야 하는데

이것을 dist[][][] == 0 ? 이라는 코드를 통해서
해당 정점을 방문했는지, 안했는지를 판단할 수 있다

이미 방문했다면, dist[][][] 기 0 이 아닐 것이고
방문한 적이 업삳면 0 일 것이기 때문이다

'''
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

N, M = map(int, input().split())
arr = [list(map(int, list(input()))) for _ in range(N)]
dist = [[[0]*2 for j in range(M)] for i in range(N)]

# dist[i][j][0] : i,j 벽 x
# dist[0][0] > 벽 부수고 이동할수 있 칸 방문할 수 있는 2가지 경우
# 1) 벽을 이전 부수고, 현재 칸을 방문했을 때  >> dist[x][y][1] == 0 ex) dist[x-1][y-1][1] z == 1 ~~~~~~ dist[pX][pY][1]
# 2) 벽 x , 현재 칸 방문했을 때  >> dist[x][y][0] == 0 ex) ~~~ dist[pX][pY][0]
dist[0][0][0] = 1
queue = deque([(0, 0, 0)])

while queue:
    x, y, z = queue.popleft()
    for i in range(4):
        nx, ny = x + dx[i], y + dy[i]

        if nx < 0 or nx >= N or ny < 0 or ny >= M:
            continue

        # 4가지 : 빈칸 > 빈칸(o) , 벽 > 빈칸 (o) , 빈칸 > 벽 (경우 : 벽x (z == 0) == 가능 ) , 벽 > 벽 ( x )
        # bfs : 한번 간 칸 >> check >> 다시 안감
        # bfs : check 배열 + dist 배열

        # 다음 칸이 0 일 때, 즉, 빈칸일 때 >> 항상 이동할 수 있다
        if arr[nx][ny] == 0 and dist[nx][ny][z] == 0:
            # 빈칸으로 이동하는 것이므로, z, 즉, 벽 관련 정보는 바뀌지 않는다
            dist[nx][ny][z] = dist[x][y][z] + 1
            queue.append((nx, ny, z))

        # 다음칸이 1 일 때, 즉, 벽일때 >> z = 0 이라면, 즉, 벽을 부순적이 없다면
        elif z == 0 and arr[nx][ny] == 1 and dist[nx][ny][z+1] == 0:
            # 벽을 부수고 이동한다
            dist[nx][ny][z+1] = dist[x][y][z] + 1
            queue.append((nx, ny, z+1))

# 목적지까지의 거리는 2개에 저장될 '수도' 있다
# z=1 일때, 즉, 벽을 부수고 이동한 적이 있을 때
# z=0 일때, 즉, 벽 안부수고 이동했을 때

if dist[N-1][M-1][0] != 0 and dist[N-1][M-1][1] != 0:
    print(min(dist[N-1][M-1]))
elif dist[N-1][M-1][0] != 0:
    print(dist[N-1][M-1][0])
elif dist[N-1][M-1][1] != 0:
    print(dist[N-1][M-1][1])
else:
    print(-1)
